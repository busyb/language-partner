<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Voice Chat Demo</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background: #0a0a0f; }
    .highlight-token {
      background: linear-gradient(120deg, rgba(250, 204, 21, 0.2) 0%, rgba(250, 204, 21, 0.4) 100%);
      cursor: pointer;
      border-radius: 0.375rem;
      padding: 0.125rem 0.375rem;
      transition: all 0.2s ease;
      border-bottom: 2px solid rgba(250, 204, 21, 0.5);
    }
    .highlight-token:hover {
      background: linear-gradient(120deg, rgba(250, 204, 21, 0.4) 0%, rgba(250, 204, 21, 0.6) 100%);
      transform: translateY(-1px);
      border-bottom-color: rgba(250, 204, 21, 0.8);
    }
    .pulse-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 180px;
      height: 180px;
      transition: transform 0.3s ease;
    }
    .idle-pulse { animation: idlePulse 3s ease-in-out infinite; }
    @keyframes idlePulse {
      0%, 100% { transform: scale(1); filter: drop-shadow(0 0 20px rgba(99, 102, 241, 0.3)); }
      50% { transform: scale(1.05); filter: drop-shadow(0 0 40px rgba(99, 102, 241, 0.5)); }
    }

    /* Listening state - pulsing rings */
    .listening-ring {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 3px solid #EF4444;
      animation: listeningPulse 2s ease-out infinite;
      opacity: 0;
    }
    .listening-ring:nth-child(2) { animation-delay: 0.5s; }
    .listening-ring:nth-child(3) { animation-delay: 1s; }

    @keyframes listeningPulse {
      0% { transform: scale(0.8); opacity: 0.8; }
      50% { opacity: 0.5; }
      100% { transform: scale(1.8); opacity: 0; }
    }

    /* Thinking state - rotating square */
    .thinking-square {
      position: absolute;
      width: 120px;
      height: 120px;
      border: 3px solid rgba(168, 85, 247, 0.6);
      border-radius: 12px;
      animation: rotateSquare 3s linear infinite;
    }

    @keyframes rotateSquare {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Responding state - breathing square */
    .responding-square {
      position: absolute;
      width: 100px;
      height: 100px;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.3), rgba(168, 85, 247, 0.3));
      border-radius: 16px;
      animation: breatheSquare 2s ease-in-out infinite;
    }

    @keyframes breatheSquare {
      0%, 100% {
        transform: scale(1) rotate(0deg);
        opacity: 0.6;
        border-radius: 16px;
      }
      50% {
        transform: scale(1.15) rotate(90deg);
        opacity: 0.9;
        border-radius: 24px;
      }
    }

    .button {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      z-index: 2;
      transition: all 0.3s ease;
      cursor: pointer;
    }
    .button-blue {
      background: linear-gradient(135deg, #6366F1 0%, #4F46E5 100%);
      box-shadow: 0 8px 32px rgba(99, 102, 241, 0.4), 0 0 0 0 rgba(99, 102, 241, 0.4);
    }
    .button-blue:hover {
      transform: scale(1.05);
      box-shadow: 0 12px 40px rgba(99, 102, 241, 0.5), 0 0 0 0 rgba(99, 102, 241, 0.5);
    }
    .button-red {
      background: linear-gradient(135deg, #EF4444 0%, #DC2626 100%);
      box-shadow: 0 8px 32px rgba(239, 68, 68, 0.5), 0 0 60px rgba(239, 68, 68, 0.3);
    }
    .button-red.active {
      box-shadow: 0 12px 48px rgba(239, 68, 68, 0.7), 0 0 80px rgba(239, 68, 68, 0.5);
      transform: scale(1.08);
    }
    #circlein {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      position: absolute;
      background: rgba(255, 255, 255, 0.08);
      z-index: 1;
    }

    .transcript-card {
      backdrop-filter: blur(20px);
      background: linear-gradient(135deg, rgba(30, 30, 45, 0.8) 0%, rgba(20, 20, 35, 0.9) 100%);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    .message-bubble {
      animation: slideIn 0.3s ease-out;
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes pulse-rotate {
      0% { transform: scale(1) rotate(0deg); }
      25% { transform: scale(1.05) rotate(3deg); }
      50% { transform: scale(1) rotate(0deg); }
      75% { transform: scale(1.05) rotate(-3deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    /* Three quick bounces in one second */
    @keyframes bounce-three {
      0%, 33%, 66%, 100% { transform: translateY(0); }
      11% { transform: translateY(-6px); }
      44% { transform: translateY(-6px); }
      77% { transform: translateY(-6px); }
    }

    /* Combine pulse + rotate + bounce */
    .animate-pulse-rotate-bounce {
      animation:
        pulse-rotate 2s ease-in-out infinite,
        bounce-three 3s ease-in-out infinite;
    }
  </style>
</head>

<body class="bg-gradient-to-br from-gray-950 via-gray-900 to-indigo-950">
  <div id="root"></div>

  <script type="text/babel">




    function TheConversationReportModal({ report, onClose }) {
      console.log("MODAL MOUNTED", report);
      if (!report) return null;

      if (typeof report === "string") {
        try {
          report = JSON.parse(report);
        } catch (e) {
          console.error("Failed to parse report JSON", e);
          return null;
        }
      }

      const scoreColor = (v) =>
        v >= 80 ? "bg-green-500" : v >= 65 ? "bg-yellow-500" : "bg-red-500";

      return (
        <div className="fixed inset-0 z-[9999] flex items-center justify-center bg-black/60 backdrop-blur-md">
          <div className="w-full max-w-3xl max-h-[90vh] overflow-y-auto rounded-2xl bg-gradient-to-br from-gray-900 via-gray-950 to-indigo-950 border border-white/10 shadow-2xl p-6 relative animate-slideUp">

            {/* Close */}
            <button
              onClick={onClose}
              className="absolute top-4 right-4 text-gray-400 hover:text-white text-xl"
            >
              ‚úï
            </button>

            {/* Header */}
            <div className="flex items-center gap-3 mb-6">
              <span className="px-3 py-1 rounded-full bg-indigo-600/30 text-indigo-300 text-xs font-semibold">
                {report.meta?.language || "lang"}
              </span>
              <span className="px-3 py-1 rounded-full bg-purple-600/30 text-purple-300 text-xs font-semibold">
                {report.meta?.level || "level"}
              </span>
              <span className="text-gray-400 text-xs">Conversation Report</span>
            </div>

            {/* Scores */}
            <section className="mb-6">
              <h3 className="text-sm font-semibold text-gray-300 mb-3">
                Overall Performance
              </h3>

              <div className="space-y-3">
                {Object.entries(report.overall_scores || {}).map(([k, v]) => (
                  <div key={k}>
                    <div className="flex justify-between text-xs text-gray-400 mb-1">
                      <span className="capitalize">{k.replace("_", " ")}</span>
                      <span>{v}%</span>
                    </div>
                    <div className="h-2 rounded-full bg-gray-800 overflow-hidden">
                      <div
                        className={`h-full ${scoreColor(v)} transition-all duration-700`}
                        style={{ width: `${v}%` }}
                      />
                    </div>
                  </div>
                ))}
              </div>
            </section>

            {/* Strengths */}
            <section className="mb-6">
              <h3 className="text-sm font-semibold text-green-400 mb-3">Strengths</h3>
              <div className="grid sm:grid-cols-2 gap-3">
                {(report.strengths || []).map((s, i) => (
                  <div
                    key={i}
                    className="bg-green-500/10 border border-green-500/20 rounded-xl p-3 text-sm text-green-200"
                  >
                    ‚úÖ {s}
                  </div>
                ))}
              </div>
            </section>

            {/* Key Issues */}
            <section className="mb-6">
              <h3 className="text-sm font-semibold text-yellow-400 mb-3">Key Issues</h3>

              <div className="space-y-3">
                {(report.key_issues || []).map((issue, i) => (
                  <div
                    key={i}
                    className="rounded-xl p-4 bg-gray-800/60 border border-white/10"
                  >
                    <div className="flex justify-between items-center mb-1">
                      <span className="text-sm text-white font-medium">{issue.issue}</span>
                      <span
                        className={`text-xs px-2 py-0.5 rounded-full ${
                          issue.impact === "low"
                            ? "bg-green-600/30 text-green-300"
                            : "bg-yellow-600/30 text-yellow-300"
                        }`}
                      >
                        {issue.impact || "unknown"} impact
                      </span>
                    </div>
                    <div className="text-xs text-gray-400 italic">
                      Example: ‚Äú{issue.example || "N/A"}‚Äù
                    </div>
                  </div>
                ))}
              </div>
            </section>

            {/* Level Alignment */}
            <section className="mb-6">
              <div
                className={`rounded-xl p-4 ${
                  report.level_alignment?.meets_expectations
                    ? "bg-indigo-500/10 border border-indigo-500/30"
                    : "bg-red-500/10 border border-red-500/30"
                }`}
              >
                <div className="font-semibold text-sm mb-1">Level Alignment</div>
                <div className="text-xs text-gray-300">
                  {report.level_alignment?.explanation || "No explanation available."}
                </div>
              </div>
            </section>

            {/* Action Plan */}
            <section>
              <h3 className="text-sm font-semibold text-indigo-300 mb-3">Action Plan</h3>

              <ul className="space-y-2 mb-3">
                {(report.action_plan?.focus_areas || []).map((a, i) => (
                  <li key={i} className="text-sm text-gray-200 flex gap-2">
                    üéØ {a}
                  </li>
                ))}
              </ul>

              <div className="rounded-xl bg-indigo-600/20 border border-indigo-500/30 p-3 text-sm text-indigo-200">
                Next session goal:{" "}
                <span className="font-semibold">
                  {report.action_plan?.next_session_goal || "N/A"}
                </span>
              </div>
            </section>
          </div>
        </div>
      );
    }


    const { useState, useEffect, useRef } = React;

    function App() {

      const [sessionId] = useState(() => {
        let id = localStorage.getItem('session_id');
        if (!id) {
          // Fallback if crypto.randomUUID is not available (e.g. non-https)
          id = typeof crypto.randomUUID === 'function'
            ? crypto.randomUUID()
            : Math.random().toString(36).substring(2) + Date.now().toString(36);
          localStorage.setItem('session_id', id);
        }
        return id;
      });
      console.log("üÜî Session ID:", sessionId);

      const [state, setState] = useState("idle");
      const [transcript, setTranscript] = useState("");
      const [response, setResponse] = useState("");
      const [speed, setSpeed] = useState(1.0);
      const [activePress, setActivePress] = useState(false);
      const [langPair, setLangPair] = useState("en-es");
      const [difficulty, setDifficulty] = useState("B1");
      const [translations, setTranslations] = useState([]);
      const [hoveredWord, setHoveredWord] = useState(null);
      const [wordTranslations, setWordTranslations] = useState({});
      const [loadingWord, setLoadingWord] = useState(null);
      const [sentenceTranslation, setSentenceTranslation] = useState(null);
      const [loadingSentence, setLoadingSentence] = useState(false);
      const [conversationCounter, setConversationCounter] = useState(0);
      const [counterThreshold, setCounterThreshold] = useState(10);
      const [report, setReport] = useState(null);
      const [loadingReport, setLoadingReport] = useState(false);
      const [showReportModal, setShowReportModal] = useState(false);
      const hoverTimeoutRef = useRef(null);
      const [cachedAudioChunks, setCachedAudioChunks] = useState([]);
      const cachedAudioRef = useRef([]);

      // Debug: Log counter changes
      useEffect(() => {
        console.log('üî¢ Conversation counter updated:', conversationCounter);
      }, [conversationCounter]);
      const [assistantSegments, setAssistantSegments] = useState([]);

      const recorderRef = useRef(null);
      const wsRef = useRef(null);
      const wsReadyRef = useRef(false);
      const audioContextRef = useRef(null);
      const audioQueueRef = useRef([]);
      const isPlayingRef = useRef(false);
      const currentSourceRef = useRef(null);
      const checkAudioIntervalRef = useRef(null);

      useEffect(() => {
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const ws = new WebSocket(`${protocol}//${window.location.host}/ws/chattime`);
        wsRef.current = ws;

        ws.onopen = () => { wsReadyRef.current = true; sendConfig(); };
        ws.onclose = () => {
          console.log("üîå WebSocket closed");
          wsReadyRef.current = false;
        };
        ws.onmessage = (e) => handleWSMessage(JSON.parse(e.data));

        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });

        return () => {
          console.log("üßπ Cleaning up WebSocket");
          ws.close();
          if (audioContextRef.current) {
            audioContextRef.current.close();
          }
          if (checkAudioIntervalRef.current) {
            clearInterval(checkAudioIntervalRef.current);
          }
        };
      }, []); // Empty dependency array - only run once!

      // Separate effect for keyboard shortcuts
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (e.code === 'Space' && !e.repeat && state === 'idle') {
            e.preventDefault();
            startRecording();
          }
        };

        const handleKeyUp = (e) => {
          if (e.code === 'Space' && (state === 'listening' || activePress)) {
            e.preventDefault();
            stopRecording();
          }
        };

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);

        return () => {
          window.removeEventListener('keydown', handleKeyDown);
          window.removeEventListener('keyup', handleKeyUp);
        };
      }, [state, activePress]); // Only keyboard listeners depend on state

      const sendConfig = (customLangPair = null, customDifficulty = null) => {
        if (!wsReadyRef.current) return;
        const langToSend = customLangPair || langPair;
        const diffToSend = customDifficulty || difficulty;
        console.log('üì° Sending config - lang_pair:', langToSend, 'difficulty:', diffToSend);
        wsRef.current.send(JSON.stringify({
          type: "config",
          session_id: sessionId,
          lang_pair: langToSend,
          difficulty: diffToSend
        }));
      };

      const handleWSMessage = (msg) => {
        switch(msg.type) {
          case "status":
            console.log("‚úÖ WS status:", msg.step);
            break;
          case "partial":
            setTranscript(prev => prev + msg.text);
            break;
          case "transcript":
            console.log("üìù Transcript:", msg.text);
            setTranscript(msg.text);
            break;
          case "translations":
            console.log("üî§ Translations:", msg.data?.translations?.length || 0);
            setTranslations(msg.data?.translations || []);
            break;
          case "audio_chunk":
            console.log("üîä Received audio_chunk - b64 length:", msg.pcm16_b64?.length || 0);
            if (!window._audioChunkCount) window._audioChunkCount = 0;
            window._audioChunkCount++;

            handleAudioChunk(msg.pcm16_b64);
            setState("responding");
            startAudioMonitoring();
            break;
          case "assistant_text":
            console.log("üí¨ Assistant text:", msg.text);
            console.log("   Previous response was:", response);
            setResponse(prev => {
              if (prev && prev !== msg.text) {
                console.warn("‚ö†Ô∏è Response changed! Old:", prev, "New:", msg.text);
              }
              return msg.text;
            });
            break;
          case "assistant_segments":
            console.log("üìä Assistant segments received:", msg.assistant_segments);
            setAssistantSegments(msg.assistant_segments || []);
            break;
          case "user_response_counter":
            console.log("üìä Conversation counter:", msg.text);
            setConversationCounter(msg.text);
            break;
          case "done":
            console.log("‚úîÔ∏è Done - Audio chunks received:", window._audioChunkCount || 0, "Queue size:", audioQueueRef.current.length, "Is playing:", isPlayingRef.current);
            window._audioChunkCount = 0;
            window._chineseChunkCount = 0;

            // Start monitoring if audio is still playing
            startAudioMonitoring();
            break;
          default:
            console.log("‚ùì Unknown WS msg type:", msg.type);
        }
      };

      // Monitor audio playback and return to idle when done
      const startAudioMonitoring = () => {
        if (checkAudioIntervalRef.current) {
          clearInterval(checkAudioIntervalRef.current);
        }

        checkAudioIntervalRef.current = setInterval(() => {
          if (!isPlayingRef.current && audioQueueRef.current.length === 0) {
            console.log("üéµ Audio finished - returning to idle");
            setState("idle");
            if (checkAudioIntervalRef.current) {
              clearInterval(checkAudioIntervalRef.current);
              checkAudioIntervalRef.current = null;
            }
          }
        }, 200);
      };

      const handleAudioChunk = (pcm16_b64) => {
        try {
          const binaryString = atob(pcm16_b64);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }

          const dataView = new DataView(bytes.buffer);
          const sampleCount = bytes.length / 2;
          const float32 = new Float32Array(sampleCount);

          for (let i = 0; i < sampleCount; i++) {
            const int16 = dataView.getInt16(i * 2, true);
            float32[i] = int16 / 32768.0;
          }

          if (langPair.includes('zh')) {
            if (!window._chineseChunkCount) window._chineseChunkCount = 0;
            window._chineseChunkCount++;
            if (window._chineseChunkCount <= 3) {
              console.log('üá®üá≥ Chinese audio chunk', window._chineseChunkCount,
                '- samples:', float32.length,
                'range:', Math.min(...float32).toFixed(3), 'to', Math.max(...float32).toFixed(3),
                'non-zero:', float32.filter(s => Math.abs(s) > 0.001).length
              );
            }
          }

          // Cache the audio chunk
          cachedAudioRef.current.push(float32);
          audioQueueRef.current.push(float32);

          if (!isPlayingRef.current) {
            playNextChunk();
          }
        } catch (err) {
          console.error("Error handling audio chunk:", err);
        }
      };

      const playNextChunk = () => {
        if (audioQueueRef.current.length === 0) {
          isPlayingRef.current = false;
          console.log("üéµ Audio queue empty, playback stopped");
          return;
        }

        const audioCtx = audioContextRef.current;
        if (!audioCtx || audioCtx.state === 'closed') {
          isPlayingRef.current = false;
          console.error("‚ùå AudioContext is closed!");
          return;
        }

        if (audioCtx.state === 'suspended') {
          console.log("‚ñ∂Ô∏è Resuming suspended AudioContext...");
          audioCtx.resume().then(() => {
            console.log("‚úÖ AudioContext resumed");
            playNextChunk();
          });
          return;
        }

        isPlayingRef.current = true;
        const chunk = audioQueueRef.current.shift();

        console.log("üéµ Playing chunk - samples:", chunk.length, "queue remaining:", audioQueueRef.current.length, "speed:", speed);

        // Create buffer from chunk
        const buffer = audioCtx.createBuffer(1, chunk.length, 24000);
        buffer.getChannelData(0).set(chunk);

        // Apply pitch-preserving time stretch if speed is not 1.0
        let processedBuffer = buffer;
        if (Math.abs(speed - 1.0) > 0.05) {
          console.log("üéõÔ∏è Applying pitch-preserving time stretch at rate:", speed);
          processedBuffer = timeStretchAudio(buffer, speed, audioCtx);
        }

        const source = audioCtx.createBufferSource();
        source.buffer = processedBuffer;
        // Don't modify playbackRate - we've already time-stretched
        source.playbackRate.value = 1.0;
        source.connect(audioCtx.destination);

        currentSourceRef.current = source;

        source.onended = () => {
          console.log("‚úîÔ∏è Chunk finished playing");
          currentSourceRef.current = null;
          playNextChunk();
        };

        try {
          source.start(0);
          console.log("‚ñ∂Ô∏è Audio source started with time-stretch at speed:", speed);
        } catch (err) {
          console.error("‚ùå Failed to start audio:", err);
          isPlayingRef.current = false;
        }
      };



      const startRecording = async () => {
        if (!wsReadyRef.current) return;

        setTranscript("");
        setResponse("");
        setAssistantSegments([]);
        audioQueueRef.current = [];
        cachedAudioRef.current = []; // Clear cached audio for new recording

        setState("listening");
        setActivePress(true);

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              sampleRate: 16000,
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          });

          const audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });

          console.log('üé§ Recording started - Sample rate:', audioCtx.sampleRate);

          const workletBlob = new Blob([`
            class RecorderProcessor extends AudioWorkletProcessor {
              constructor() {
                super();
                this.chunkCount = 0;
              }

              process(inputs) {
                const input = inputs[0];
                if (input.length > 0) {
                  const channel = input[0];
                  const pcm16 = new Int16Array(channel.length);
                  for (let i = 0; i < channel.length; i++) {
                    let s = Math.max(-1, Math.min(1, channel[i]));
                    pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
                  }
                  this.chunkCount++;

                  if (this.chunkCount <= 3) {
                    console.log('üìä Audio chunk', this.chunkCount, '- samples:', pcm16.length, 'first values:', pcm16.slice(0, 5));
                  }

                  this.port.postMessage(pcm16.buffer, [pcm16.buffer]);
                }
                return true;
              }
            }
            registerProcessor('recorder-processor', RecorderProcessor);
          `], { type: 'application/javascript' });

          const workletURL = URL.createObjectURL(workletBlob);
          await audioCtx.audioWorklet.addModule(workletURL);

          const source = audioCtx.createMediaStreamSource(stream);
          const recorderNode = new AudioWorkletNode(audioCtx, 'recorder-processor');

          let chunksSent = 0;
          recorderNode.port.onmessage = (e) => {
            if (!wsReadyRef.current) return;
            const b64 = arrayBufferToBase64(e.data);
            chunksSent++;

            if (chunksSent <= 3) {
              console.log('üì§ Sending chunk', chunksSent, '- base64 length:', b64.length);
            }

            wsRef.current.send(JSON.stringify({ type: "audio", pcm16_b64: b64 }));
          };

          source.connect(recorderNode);
          recorderNode.connect(audioCtx.destination);

          recorderRef.current = { ctx: audioCtx, stream, recorderNode };
        } catch (err) {
          console.error("Recording failed:", err);
          setState("idle");
          setActivePress(false);
        }
      };

      const stopRecording = () => {
        if (!recorderRef.current) return;
        const { ctx, stream, recorderNode } = recorderRef.current;

        recorderNode.disconnect();
        ctx.close();
        stream.getTracks().forEach(t => t.stop());
        recorderRef.current = null;

        if (wsReadyRef.current) wsRef.current.send(JSON.stringify({ type: "end_audio" }));

        setActivePress(false);
        setState("processing");
      };

      const arrayBufferToBase64 = (buffer) => {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const chunkSize = 0x8000;
        for (let i = 0; i < bytes.length; i += chunkSize) {
          let chunk = bytes.subarray(i, i + chunkSize);
          binary += String.fromCharCode(...chunk);
        }
        return btoa(binary);
      };

      // Pitch-preserving time stretch using overlap-add method
      const timeStretchAudio = (audioBuffer, rate, audioContext) => {
        if (rate === 1.0) return audioBuffer;

        const originalData = audioBuffer.getChannelData(0);
        const originalLength = originalData.length;
        const newLength = Math.floor(originalLength / rate);

        // Create new buffer for stretched audio
        const stretchedBuffer = audioContext.createBuffer(1, newLength, audioBuffer.sampleRate);
        const stretchedData = stretchedBuffer.getChannelData(0);

        // Time-stretch parameters
        const windowSize = 2048; // Analysis window size
        const hopSize = Math.floor(windowSize / 4); // 75% overlap
        const synthesisHop = Math.floor(hopSize * rate);

        // Hanning window for smooth transitions
        const window = new Float32Array(windowSize);
        for (let i = 0; i < windowSize; i++) {
          window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / (windowSize - 1)));
        }

        let inputPos = 0;
        let outputPos = 0;

        // Overlap-add time stretching
        while (inputPos + windowSize < originalLength && outputPos + windowSize < newLength) {
          // Apply windowed segment
          for (let i = 0; i < windowSize && outputPos + i < newLength; i++) {
            const inputIndex = Math.floor(inputPos + i);
            if (inputIndex < originalLength) {
              stretchedData[outputPos + i] += originalData[inputIndex] * window[i];
            }
          }

          inputPos += synthesisHop;
          outputPos += hopSize;
        }

        // Normalize to prevent clipping
        let maxVal = 0;
        for (let i = 0; i < newLength; i++) {
          maxVal = Math.max(maxVal, Math.abs(stretchedData[i]));
        }
        if (maxVal > 0.95) {
          const normalizeGain = 0.95 / maxVal;
          for (let i = 0; i < newLength; i++) {
            stretchedData[i] *= normalizeGain;
          }
        }

        return stretchedBuffer;
      };

      const slower = () => {
        setSpeed(prev => {
          const next = Math.max(0.6, +(prev - 0.1).toFixed(1));
          console.log("üê¢ Speed decreased to:", next);
          // Force re-render by triggering a playback update
          if (isPlayingRef.current && audioQueueRef.current.length > 0) {
            console.log("‚è∏Ô∏è Speed changed during playback - will apply to next chunk");
          }
          return next;
        });
      };

      const faster = () => {
        setSpeed(prev => {
          const next = Math.min(1.8, +(prev + 0.1).toFixed(1));
          console.log("üêá Speed increased to:", next);
          // Force re-render by triggering a playback update
          if (isPlayingRef.current && audioQueueRef.current.length > 0) {
            console.log("‚è∏Ô∏è Speed changed during playback - will apply to next chunk");
          }
          return next;
        });
      };

      const speakWord = (text, lang) => {
        if(!window.speechSynthesis) return;
        const u = new SpeechSynthesisUtterance(text);
        u.lang = lang || "en";
        const match = window.speechSynthesis.getVoices().find(v => v.lang.startsWith(lang));
        if(match) u.voice = match;
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
      };

      const replayResponse = () => {
        if (cachedAudioRef.current.length === 0) {
          console.log("‚ö†Ô∏è No cached audio to replay");
          return;
        }

        console.log("üîÅ Replaying cached audio - chunks:", cachedAudioRef.current.length);

        // Stop current playback
        if (currentSourceRef.current) {
          currentSourceRef.current.stop();
          currentSourceRef.current = null;
        }

        // Clear queue and reload from cache
        audioQueueRef.current = [...cachedAudioRef.current];
        isPlayingRef.current = false;

        setState("responding");
        playNextChunk();
        startAudioMonitoring();
      };

      const translateSentence = async (text) => {
        const [nativeLang, practicingLang] = langPair.split('-');
        const cacheKey = `sentence-${text}-${practicingLang}-${nativeLang}`;

        // Return cached translation if exists
        if (wordTranslations[cacheKey]) {
          return wordTranslations[cacheKey];
        }

        setLoadingSentence(true);

        try {
          const response = await fetch('/translate/sentence', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              text: text,
              from_code: practicingLang,
              to_code: nativeLang
            })
          });

          if (!response.ok) throw new Error('Translation failed');

          const data = await response.json();

          // Cache the translation
          setWordTranslations(prev => ({
            ...prev,
            [cacheKey]: data
          }));

          return data;
        } catch (err) {
          console.error('Sentence translation error:', err);
          return null;
        } finally {
          setLoadingSentence(false);
        }
      };

      const handleSentenceTranslate = async (text, event) => {
        event.stopPropagation();

        const translation = await translateSentence(text);

        if (translation) {
          setSentenceTranslation({
            original: text,
            translation: translation.text,
            position: event.target.getBoundingClientRect()
          });
        }
      };

      const fetchConversationReport = async () => {
        setLoadingReport(true);
        try {
          const response = await fetch('/report/conversation', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              session_id: sessionId,
              lang_pair: langPair,
              difficulty: difficulty
            })
          });

          if (!response.ok) {
            throw new Error('Failed to fetch report');
          }

          const data = await response.json();
          setReport(data);
          setShowReportModal(true);
          console.log('üìä Report received:', data);
        } catch (err) {
          console.error('Failed to fetch report:', err);
          alert('Failed to generate report: ' + err.message);
        } finally {
          console.log('üìä Report loading false');
          setLoadingReport(false);
        }
      };

      const translateWord = async (word, fromLang, toLang) => {
        const cacheKey = `${word}-${fromLang}-${toLang}`;

        // Return cached translation if exists
        if (wordTranslations[cacheKey]) {
          return wordTranslations[cacheKey];
        }

        setLoadingWord(word);

        try {
          const response = await fetch('/translate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              text: word,
              from_code: fromLang,
              to_code: toLang
            })
          });

          if (!response.ok) throw new Error('Translation failed');

          const data = await response.json();

          // Cache the translation
          setWordTranslations(prev => ({
            ...prev,
            [cacheKey]: data
          }));

          return data;
        } catch (err) {
          console.error('Translation error:', err);
          return null;
        } finally {
          setLoadingWord(null);
        }
      };

      const handleWordClick = async (word, isUserMessage, event) => {
        // Prevent event bubbling
        event.stopPropagation();

        const [nativeLang, practicingLang] = langPair.split('-');

        // For user messages, check if word was detected as code-switched
        if (isUserMessage) {
          const detectedTranslation = translations.find(
            t => t.token.toLowerCase() === word.toLowerCase()
          );

          if (detectedTranslation) {
            // Word was code-switched - use detected translation
            console.log('üîÑ Using detected code-switch translation:', detectedTranslation);
            const rect = event.target.getBoundingClientRect();

            setHoveredWord({
              word: detectedTranslation.token,
              translation: detectedTranslation.translation,
              originalLanguage: detectedTranslation.lang,  // Original language of the word
              position: rect
            });
            return;
          }
        }

        // Standard translation:
        // - AI speaks practicing language ‚Üí translate TO native
        // - User speaks practicing language ‚Üí translate TO native
        const fromLang = practicingLang;
        const toLang = nativeLang;

        console.log('üî§ Translating word:', word, 'from', fromLang, 'to', toLang, '(isUser:', isUserMessage, ')');

        const translation = await translateWord(word, fromLang, toLang);

        console.log('üì• Translation received:', translation);

        if (translation) {
          const rect = event.target.getBoundingClientRect();
          console.log('üìç Word position:', rect);

          setHoveredWord({
            word,
            translation: translation.text,
            originalLanguage: fromLang,  // The original language (practicing lang)
            position: rect
          });
        }
      };

      const renderChineseWithPinyin = (segments) => {
        if (!segments || segments.length === 0) return null;

        return segments.map((segment, i) => {
          if (segment.type === 'chinese') {
            // Each segment is a word group - keep it together
            return (
              <span key={i} className="inline-flex flex-col items-center mr-2">
                <span
                  onClick={(e) => handleWordClick(segment.chinese, false, e)}
                  className="inline-block cursor-pointer transition-all duration-200 hover:bg-white/10 hover:scale-105 rounded px-1"
                >
                  {segment.chinese}
                </span>
                <span className="text-xs text-amber-400 font-mono whitespace-nowrap">
                  {segment.pinyin}
                </span>
              </span>
            );
          } else if (segment.type === 'text') {
            // Regular text/punctuation
            return <span key={i}>{segment.content}</span>;
          }
          return null;
        });
      };




      const renderClickableText = (text, isUserMessage) => {
        if (!text) return null;

        // For AI messages in Chinese, use segments if available
        if (!isUserMessage && langPair.includes('zh') && assistantSegments.length > 0) {
          return renderChineseWithPinyin(assistantSegments);
        }

        // Split by words but keep punctuation
        const tokens = text.split(/(\s+|[.,!?;:¬ø¬°„ÄÇÔºÅÔºü„ÄÅ])/);

        return tokens.map((token, i) => {
          // Skip whitespace and punctuation
          if (!token.trim() || /^[.,!?;:¬ø¬°„ÄÇÔºÅÔºü„ÄÅ\s]+$/.test(token)) {
            return <span key={i}>{token}</span>;
          }

          const isLoading = loadingWord === token;

          // Check if this word has a code-switch translation (for user messages)
          const codeSwitch = isUserMessage
            ? translations.find(t => t.token.toLowerCase() === token.toLowerCase())
            : null;

          // Check cache for standard translations (always practicing ‚Üí native)
          const [nativeLang, practicingLang] = langPair.split('-');
          const cacheKey = `${token}-${practicingLang}-${nativeLang}`;
          const hasTranslation = wordTranslations[cacheKey];

          return (
            <span
              key={i}
              onClick={(e) => handleWordClick(token, isUserMessage, e)}
              className={`
                inline-block cursor-pointer transition-all duration-200
                hover:bg-white/10 hover:scale-105 rounded px-1 -mx-1
                ${isLoading ? 'opacity-50 animate-pulse' : ''}
                ${codeSwitch ? 'bg-yellow-500/20 border-b-2 border-yellow-400' : ''}
                ${hasTranslation ? 'underline decoration-dotted decoration-indigo-400' : ''}
              `}
              style={{ position: 'relative' }}
              title={codeSwitch ? `Code-switched: ${codeSwitch.translation}` : ''}
            >
              {token}
            </span>
          );
        });
      };

      const highlightText = (text) => {
        if(!text) return null;
        const words = text.split(/(\s+)/);
        return words.map((word, i) => {
          const match = translations.find(t => t.token.toLowerCase() === word.toLowerCase());
          if(match) {
            const titleText = match.translation + " (" + match.trans_lang + ")";
            return (
              <span
                key={i}
                className="highlight-token"
                title={titleText}
                onClick={() => speakWord(match.translation, match.trans_lang)}
              >
                {word}
              </span>
            );
          }
          return word;
        });
      };

      const getLanguageEmoji = (pair) => {
        const emojiMap = {
          'en-es': 'üá™üá∏', 'es-en': 'üá∫üá∏',
          'en-fr': 'üá´üá∑', 'fr-en': 'üá∫üá∏',
          'en-zh': 'üá®üá≥', 'zh-en': 'üá∫üá∏'
        };
        return emojiMap[pair] || 'üåç';
      };






      return (
        <div className="min-h-screen flex flex-col items-center justify-center text-white p-4 sm:p-6 relative overflow-auto">

          {/* Sentence Translation Popup */}
          {sentenceTranslation && (
            <div
              className="fixed z-[9999] bg-gray-900 border-2 border-indigo-500 rounded-xl shadow-2xl p-4 min-w-[200px] max-w-[90vw] max-h-[60vh] overflow-auto"
              style={{
                left: (() => {
                  const popupWidth = 280;
                  const screenWidth = window.innerWidth;
                  let x = sentenceTranslation.position.left + sentenceTranslation.position.width / 2;

                  // Center on mobile
                  if (screenWidth < 640) {
                    return '50%';
                  }

                  // Prevent overflow right
                  if (x + popupWidth / 2 > screenWidth - 20) x = screenWidth - popupWidth / 2 - 20;
                  // Prevent overflow left
                  if (x - popupWidth / 2 < 20) x = popupWidth / 2 + 20;
                  return `${x}px`;
                })(),
                top: (() => {
                  const popupHeight = 150;
                  const screenHeight = window.innerHeight;
                  const screenWidth = window.innerWidth;
                  let y = sentenceTranslation.position.top - 10;

                  // Center vertically on mobile
                  if (screenWidth < 640) {
                    return '50%';
                  }

                  // If too high, move below the element
                  if (y - popupHeight < 10) y = sentenceTranslation.position.bottom + 10;
                  // Prevent bottom overflow
                  if (y + popupHeight > screenHeight - 10) y = screenHeight - popupHeight - 10;
                  return `${y}px`;
                })(),
                transform: window.innerWidth < 640 ? 'translate(-50%, -50%)' : 'translate(-50%, -100%)',
                pointerEvents: 'auto'
              }}
              onClick={(e) => e.stopPropagation()}
              onMouseLeave={() => {
                hoverTimeoutRef.current = setTimeout(() => {
                  setSentenceTranslation(null);
                }, 300);
              }}
              onMouseEnter={() => {
                if (hoverTimeoutRef.current) {
                  clearTimeout(hoverTimeoutRef.current);
                  hoverTimeoutRef.current = null;
                }
              }}
            >
              <div className="flex items-start gap-3">
                <div className="flex-1">
                  <div className="text-xs text-gray-400 mb-1 font-medium">Original</div>
                  <div className="text-white font-semibold text-lg mb-1">{sentenceTranslation.original}</div>
                  <div className="text-xs text-indigo-300">{sentenceTranslation.translation}</div>
                </div>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    console.log('üîä Playing original sentence:', sentenceTranslation.original);
                    speakWord(sentenceTranslation.original, langPair.split('-')[1]);
                  }}
                  className="flex-shrink-0 w-10 h-10 rounded-lg bg-indigo-600 hover:bg-indigo-500 transition-all flex items-center justify-center active:scale-95"
                  title="Pronounce original sentence"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" width="20" height="20">
                    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                  </svg>
                </button>
              </div>
              {/* Speech bubble arrow */}
              <div className="absolute -bottom-2 left-1/2 -translate-x-1/2 w-4 h-4 bg-gray-900 border-r border-b border-indigo-500 transform rotate-45"></div>
            </div>
          )}







          {/* Translation Popup - Move to top level so it's not clipped */}
          {hoveredWord && (
            <div
              className="fixed z-[9999] bg-gray-900 border-2 border-indigo-500 rounded-xl shadow-2xl p-4 min-w-[200px]"
              style={{
                left: (() => {
                  const popupWidth = 240;
                  const screenWidth = window.innerWidth;
                  let x = hoveredWord.position.left + hoveredWord.position.width / 2;

                  // Center on mobile
                  if (screenWidth < 640) {
                    return '50%';
                  }

                  // Prevent overflow
                  if (x + popupWidth / 2 > screenWidth - 20) x = screenWidth - popupWidth / 2 - 20;
                  if (x - popupWidth / 2 < 20) x = popupWidth / 2 + 20;
                  return `${x}px`;
                })(),
                top: (() => {
                  const popupHeight = 120;
                  const screenHeight = window.innerHeight;
                  const screenWidth = window.innerWidth;
                  let y = hoveredWord.position.top - 10;

                  // Center vertically on mobile
                  if (screenWidth < 640) {
                    return '50%';
                  }

                  if (y - popupHeight < 10) y = hoveredWord.position.bottom + 10;
                  if (y + popupHeight > screenHeight - 10) y = screenHeight - popupHeight - 10;
                  return `${y}px`;
                })(),
                transform: window.innerWidth < 640 ? 'translate(-50%, -50%)' : 'translate(-50%, -100%)',
                pointerEvents: 'auto'
              }}
              onClick={(e) => e.stopPropagation()}
              onMouseEnter={() => {
                // Cancel any pending hide
                if (hoverTimeoutRef.current) {
                  clearTimeout(hoverTimeoutRef.current);
                  hoverTimeoutRef.current = null;
                }
              }}
              onMouseLeave={() => {
                // Delay hiding the popup
                hoverTimeoutRef.current = setTimeout(() => {
                  setHoveredWord(null);
                }, 300);
              }}
            >
              <div className="flex items-start gap-3">
                <div className="flex-1">
                  <div className="text-xs text-gray-400 mb-1 font-medium">Original</div>
                  <div className="text-white font-semibold text-lg mb-1">{hoveredWord.word}</div>
                  <div className="text-xs text-indigo-300">{hoveredWord.translation}</div>
                </div>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    console.log('üîä Playing original word:', hoveredWord.word, hoveredWord.originalLanguage);
                    speakWord(hoveredWord.word, hoveredWord.originalLanguage);
                  }}
                  className="flex-shrink-0 w-10 h-10 rounded-lg bg-indigo-600 hover:bg-indigo-500 transition-all flex items-center justify-center active:scale-95"
                  title="Pronounce original"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" width="20" height="20">
                    <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                  </svg>
                </button>
              </div>
              {/* Speech bubble arrow */}
              <div className="absolute -bottom-2 left-1/2 -translate-x-1/2 w-4 h-4 bg-gray-900 border-r border-b border-indigo-500 transform rotate-45"></div>
            </div>
          )}

          {/* Top Right Language Selector */}
          <div className="fixed top-6 right-6 z-50 flex flex-col sm:flex-row gap-3 sm:gap-3 items-center sm:items-start sm:justify-end w-auto sm:w-auto">
            <a
              href="/pronunciation"
              className="w-full sm:w-auto px-4 py-2.5 bg-purple-600/80 backdrop-blur-xl border border-purple-500/50 rounded-xl text-sm font-semibold text-white hover:bg-purple-500/80 transition-all shadow-lg text-center"
              title="Practice pronunciation"
            >
              üìù Practice
            </a>

            <select
              value={langPair}
              onChange={e => {
                const newLang = e.target.value;
                console.log('üåç Language changed to:', newLang);
                setLangPair(newLang);
                sendConfig(newLang);
              }}
              className="w-full sm:w-auto px-4 py-2.5 bg-gray-900/80 backdrop-blur-xl border border-gray-700/50 rounded-xl text-sm font-semibold text-white focus:outline-none focus:ring-2 focus:ring-indigo-500/50 focus:border-indigo-400/50 transition-all hover:bg-gray-800/80 cursor-pointer shadow-lg"
            >
              <option value="en-es">üá™üá∏ Spanish</option>
              <option value="es-en">üá∫üá∏ English</option>
              <option value="en-fr">üá´üá∑ French</option>
              <option value="fr-en">üá∫üá∏ English (from FR)</option>
              <option value="en-zh">üá®üá≥ Chinese</option>
              <option value="zh-en">üá∫üá∏ English (from ZH)</option>
            </select>

            <select
              value={difficulty}
              onChange={(e) => {
                const newDifficulty = e.target.value;
                console.log('üåç Difficulty changed to:', newDifficulty);
                setDifficulty(newDifficulty);
                sendConfig(langPair, newDifficulty);
              }}
              className="w-full sm:w-auto px-3 py-2 sm:px-4 sm:py-2 bg-gray-900/80 backdrop-blur-xl border border-gray-700/50 rounded-xl text-xs sm:text-sm font-semibold focus:outline-none focus:ring-2 focus:ring-indigo-500/50"
            >
              <option value="A1">A1/HSK 1</option>
              <option value="A2">A2/HSK 2</option>
              <option value="B1">B1/HSK 3</option>
              <option value="B2">B2/HSK 4-5</option>
              <option value="C1">C1/HSK 5-6</option>
              <option value="C2">C2/HSK 6</option>
            </select>
          </div>


          {/* Main Content */}
          <div className="w-full max-w-3xl mx-auto space-y-8">

            {/* Mic Button */}
            <div className="flex items-center justify-center">
              <button
                onMouseDown={startRecording}
                onMouseUp={stopRecording}
                onMouseLeave={() => {
                  if (state === "listening") stopRecording();
                }}
                onTouchStart={startRecording}
                onTouchEnd={stopRecording}
                className="pulse-wrapper"
              >
                {/* Listening - Pulsing rings */}
                {state === "listening" && (
                  <>
                    <div className="listening-ring"></div>
                    <div className="listening-ring"></div>
                    <div className="listening-ring"></div>
                  </>
                )}

                {/* Processing/Thinking - Rotating square */}
                {state === "processing" && (
                  <div className="thinking-square"></div>
                )}

                {/* Responding - Breathing square */}
                {state === "responding" && (
                  <div className="responding-square"></div>
                )}

                <div className={`button ${state === "listening" ? `button-red ${activePress ? "active" : ""}` : "button-blue idle-pulse"}`}>
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white" width="48" height="48">
                    <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                    <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                  </svg>
                </div>
                <div className="button" id="circlein"></div>
              </button>
            </div>

            {/* Status Indicator */}
            <div className="text-center">
              {state === "idle" && (
                <p className="text-gray-400 text-sm font-medium">
                  Hold <kbd className="px-2 py-1 bg-gray-800 rounded border border-gray-700 text-xs">Space</kbd> or press to speak {getLanguageEmoji(langPair)}
                </p>
              )}
              {state === "listening" && (
                <p className="text-red-400 text-sm font-medium animate-pulse">‚óè Listening...</p>
              )}
              {state === "processing" && (
                <p className="text-purple-400 text-sm font-medium">Thinking...</p>
              )}
              {state === "responding" && (
                <p className="text-indigo-400 text-sm font-medium">Speaking...</p>
              )}
            </div>

            {/* Transcript Cards */}
            {(transcript || response) && (
              <div className="transcript-card rounded-2xl p-6 space-y-4" style={{ position: 'relative' }}>
                {transcript && (
                  <div className="message-bubble">
                    <div className="flex items-start gap-3">
                      <div className="flex-shrink-0 w-8 h-8 rounded-full bg-gradient-to-br from-green-500 to-emerald-600 flex items-center justify-center text-white font-bold text-sm shadow-lg">
                        Y
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="text-xs text-gray-400 font-medium mb-1">You</div>
                        <div className="text-green-100 text-base leading-relaxed">
                          {renderClickableText(transcript, true)}
                        </div>
                      </div>
                    </div>
                  </div>
                )}


                {response && (
                  <div className="message-bubble">
                    <div className="flex items-start gap-3">
                      <div
                        className="flex-shrink-0 w-8 h-8 rounded-full bg-gradient-to-br from-indigo-500 to-purple-600
                                   flex items-center justify-center text-white font-bold text-sm shadow-lg cursor-pointer
                                   animate-pulse-rotate-bounce"
                        title="Translate this sentence"
                        onClick={(e) => handleSentenceTranslate(response, e)}
                      >
                        AI
                      </div>
                      <div className="flex-1 min-w-0">
                        <div className="text-xs text-gray-400 font-medium mb-1">Assistant</div>
                        <div className="text-indigo-100 text-base leading-relaxed">
                          {renderClickableText(response, false)}
                        </div>
                      </div>
                      {/* Action buttons container */}
                      <div className="flex gap-2">
                        {/* Replay button */}
                        {cachedAudioRef.current.length > 0 && (
                          <button
                            onClick={() => replayResponse()}
                            className="w-8 h-8 rounded-lg bg-purple-600 hover:bg-purple-500 transition flex items-center justify-center text-white active:scale-95"
                            title="Replay audio"
                          >
                            <svg xmlns="http://www.w3.org/2000/svg" fill="white" viewBox="0 0 24 24" width="16" height="16">
                              <path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/>
                            </svg>
                          </button>
                        )}

                        {/* Translate sentence button */}
                        <button
                          onClick={(e) => handleSentenceTranslate(response, e)}
                          className="w-8 h-8 rounded-lg bg-indigo-600 hover:bg-indigo-500 transition flex items-center justify-center text-white active:scale-95"
                          title="Translate sentence"
                        >
                          <svg xmlns="http://www.w3.org/2000/svg" fill="white" viewBox="0 0 24 24" width="16" height="16">
                            <path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"/>
                          </svg>
                        </button>
                      </div>

                    </div>
                  </div>
                )}
              </div>
            )}

            {/* Speed Controls */}
            <div className="flex items-center justify-center gap-3">
              <button
                onClick={slower}
                className="w-10 h-10 rounded-lg bg-gray-800/80 backdrop-blur-sm border border-gray-700/50 hover:bg-gray-700/80 hover:border-gray-600 transition-all flex items-center justify-center text-white font-bold text-xl shadow-lg active:scale-95"
                title="Slower"
              >
                ‚àí
              </button>
              <div className="px-4 py-2 bg-gray-900/60 backdrop-blur-sm border border-gray-700/50 rounded-lg">
                <div className="flex flex-col items-center">
                  <span className="text-sm font-mono text-gray-300">{speed.toFixed(1)}√ó</span>
                  <span className="text-xs text-gray-500">pitch preserved</span>
                </div>
              </div>
              <button
                onClick={faster}
                className="w-10 h-10 rounded-lg bg-gray-800/80 backdrop-blur-sm border border-gray-700/50 hover:bg-gray-700/80 hover:border-gray-600 transition-all flex items-center justify-center text-white font-bold text-xl shadow-lg active:scale-95"
                title="Faster"
              >
                +
              </button>
            </div>
          </div>

          {/* Background Decoration */}
          <div className="fixed inset-0 pointer-events-none overflow-hidden -z-10">
            <div className="absolute top-1/4 left-1/4 w-96 h-96 bg-indigo-500/10 rounded-full blur-3xl"></div>
            <div className="absolute bottom-1/4 right-1/4 w-96 h-96 bg-purple-500/10 rounded-full blur-3xl"></div>
          </div>

          {/* Feedback Button */}
          <div className="fixed bottom-4 sm:bottom-6 left-4 sm:left-6 z-50">
            <button
              onClick={() => fetchConversationReport()}
              disabled={conversationCounter <= counterThreshold || loadingReport}
              className={`px-4 py-2.5 rounded-xl text-xs sm:text-sm font-semibold transition-all shadow-lg flex items-center gap-2 ${
                conversationCounter > counterThreshold
                  ? "bg-green-600 hover:bg-green-500 text-white cursor-pointer"
                  : "bg-gray-700 text-gray-400 cursor-not-allowed"
              }`}
              title={
                conversationCounter <= counterThreshold
                  ? `Have ${11 - conversationCounter} more exchanges to unlock feedback`
                  : "View conversation feedback"
              }
            >
              {loadingReport ? (
                <div className="flex items-center gap-2">
                  <svg
                    className="animate-spin h-4 w-4"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                  >
                    <circle
                      className="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      strokeWidth="4"
                    ></circle>
                    <path
                      className="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    ></path>
                  </svg>
                  Loading...
                </div>
              ) : (
                <span>üìä Feedback ({conversationCounter}/{counterThreshold})</span>
              )}
            </button>
            {showReportModal && report && (
              <TheConversationReportModal
                report={report}
                onClose={() => setShowReportModal(false)}
              />
            )}
          </div>


        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById("root")).render(<App />);


  </script>
</body>
</html>